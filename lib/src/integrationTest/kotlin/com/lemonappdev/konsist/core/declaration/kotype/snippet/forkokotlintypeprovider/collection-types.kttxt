interface CollectionsInterface {
    val abstractList: AbstractList<Int>
    val abstractMap: AbstractMap<Int, Int>
    val abstractMutableCollection: AbstractMutableCollection<Int>
    val abstractMutableList: AbstractMutableList<Int>
    val abstractMutableMap: AbstractMutableMap<Int, Int>
    val abstractMutableSet: AbstractMutableSet<Int>
    val abstractSet: AbstractSet<Int>
    val arrayDeque: ArrayDeque<Int>
    val arrayList: ArrayList<Int>
    val collection: Collection<Int>
    val hashMap: HashMap<Int, Int>
    val hashSet: HashSet<Int>
    val linkedHashMap: LinkedHashMap<Int, Int>
    val linkedHashSet: LinkedHashSet<Int>
    val list: List<Int>
    val map: Map<Int, Int>
    val mutableCollection: MutableCollection<Int>
    val mutableList: MutableList<Int>
    val mutableMap: MutableMap<Int, Int>
    val mutableSet: MutableSet<Int>
    val set: Set<Int>

    val nullableAbstractCollection: AbstractCollection<Int>?
    val nullableAbstractIterator: AbstractIterator<Int>?
    val nullableAbstractList: AbstractList<Int>?
    val nullableAbstractMap: AbstractMap<Int, Int>?
    val nullableAbstractMutableCollection: AbstractMutableCollection<Int>?
    val nullableAbstractMutableList: AbstractMutableList<Int>?
    val nullableAbstractMutableMap: AbstractMutableMap<Int, Int>?
    val nullableAbstractMutableSet: AbstractMutableSet<Int>?
    val nullableAbstractSet: AbstractSet<Int>?
    val nullableArrayDeque: ArrayDeque<Int>?
    val nullableArrayList: ArrayList<Int>?
    val nullableCollection: Collection<Int>?
    val nullableHashMap: HashMap<Int, Int>?
    val nullableHashSet: HashSet<Int>?
    val nullableLinkedHashMap: LinkedHashMap<Int, Int>?
    val nullableLinkedHashSet: LinkedHashSet<Int>?
    val nullableList: List<Int>?
    val nullableMap: Map<Int, Int>?
    val nullableMutableCollection: MutableCollection<Int>?
    val nullableMutableList: MutableList<Int>?
    val nullableMutableMap: MutableMap<Int, Int>?
    val nullableMutableSet: MutableSet<Int>?
    val nullableSet: Set<Int>?
}
